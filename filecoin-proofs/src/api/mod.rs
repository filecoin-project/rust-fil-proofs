use crate::api::responses::err_code_and_msg;
use crate::api::responses::FCPResponseStatus;
use crate::api::responses::FFIPieceMetadata;
use crate::api::responses::FFISealStatus;
use crate::api::sector_builder::metadata::SealStatus;
use crate::api::sector_builder::SectorBuilder;
use ffi_toolkit::rust_str_to_c_str;
use ffi_toolkit::{c_str_to_pbuf, c_str_to_rust_str, raw_ptr};
use libc;
use sector_base::api::disk_backed_storage::new_sector_config;
use sector_base::api::disk_backed_storage::SBConfiguredStore;
use sector_base::api::sector_store::SectorStore;
use std::ffi::CString;
use std::mem;
use std::ptr;
use std::slice::from_raw_parts;

pub mod internal;
pub mod responses;
mod sector_builder;

type SectorAccess = *const libc::c_char;

/// Note: These values need to be kept in sync with what's in api/internal.rs.
/// Due to limitations of cbindgen, we can't define a constant whose value is
/// a non-primitive (e.g. an expression like 192 * 2 or internal::STUFF) and
/// see the constant in the generated C-header file.
pub const API_POREP_PROOF_BYTES: usize = 384;
pub const API_POST_PROOF_BYTES: usize = 192;

#[repr(C)]
pub enum ConfiguredStore {
    Live = 0,
    Test = 1,
    ProofTest = 2,
}

/// Seals a sector and returns its commitments and proof.
/// Unsealed data is read from `unsealed`, sealed, then written to `sealed`.
///
/// # Arguments
///
/// * `ss_ptr`        - pointer to a boxed SectorStore
/// * `unsealed`      - access to unsealed sector to be sealed
/// * `sealed`        - access to which sealed sector should be written
/// * `prover_id`     - uniquely identifies the prover
/// * `sector_id`     - uniquely identifies a sector
#[no_mangle]
pub unsafe extern "C" fn seal(
    ss_ptr: *mut Box<SectorStore>,
    unsealed_path: SectorAccess,
    sealed_path: SectorAccess,
    prover_id: &[u8; 31],
    sector_id: &[u8; 31],
) -> *mut responses::SealResponse {
    let unsealed_path_buf = c_str_to_pbuf(unsealed_path);
    let sealed_path_buf = c_str_to_pbuf(sealed_path);

    let result = internal::seal(
        &**ss_ptr,
        &unsealed_path_buf,
        &sealed_path_buf,
        *prover_id,
        *sector_id,
    );

    let mut response: responses::SealResponse = Default::default();

    match result {
        Ok((comm_r, comm_d, comm_r_star, snark_proof)) => {
            response.status_code = FCPResponseStatus::FCPNoError;

            response.comm_r[..32].clone_from_slice(&comm_r[..32]);
            response.comm_d[..32].clone_from_slice(&comm_d[..32]);
            response.comm_r_star[..32].clone_from_slice(&comm_r_star[..32]);
            response.proof[..API_POREP_PROOF_BYTES]
                .clone_from_slice(&snark_proof[..API_POREP_PROOF_BYTES]);
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err.into());
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// Verifies the output of seal.
///
/// # Arguments
///
/// * `cfg_ptr`     - pointer to ConfiguredStore
/// * `comm_r`      - replica commitment
/// * `comm_d`      - data commitment
/// * `comm_r_star` - layer-aggregated replica commitment
/// * `prover_id`   - uniquely identifies the prover
/// * `sector_id`   - uniquely identifies the sector
/// * `proof`       - the proof, generated by seal()
#[no_mangle]
pub unsafe extern "C" fn verify_seal(
    cfg_ptr: *const ConfiguredStore,
    comm_r: &[u8; 32],
    comm_d: &[u8; 32],
    comm_r_star: &[u8; 32],
    prover_id: &[u8; 31],
    sector_id: &[u8; 31],
    proof: &[u8; API_POREP_PROOF_BYTES],
) -> *mut responses::VerifySealResponse {
    let mut response: responses::VerifySealResponse = Default::default();

    if let Some(cfg) = cfg_ptr.as_ref() {
        let cfg = new_sector_config(&cfg.into());

        match internal::verify_seal(
            &(*cfg),
            *comm_r,
            *comm_d,
            *comm_r_star,
            *prover_id,
            *sector_id,
            proof,
        ) {
            Ok(true) => {
                response.status_code = FCPResponseStatus::FCPNoError;
                response.is_valid = true;
            }
            Ok(false) => {
                response.status_code = FCPResponseStatus::FCPNoError;
                response.is_valid = false;
            }
            Err(err) => {
                let (code, ptr) = err_code_and_msg(&err.into());
                response.status_code = code;
                response.error_msg = ptr;
            }
        }
    } else {
        response.status_code = FCPResponseStatus::FCPCallerError;

        let msg = CString::new("caller did not provide ConfiguredStore").unwrap();
        response.error_msg = msg.as_ptr();
        mem::forget(msg);
    }

    raw_ptr(response)
}

/// Unseals a range of bytes from a sealed sector and writes the resulting raw (unpreprocessed) sector to `output path`.
/// Returns a response indicating the number of original (unsealed) bytes which were written to `output_path`.
///
/// If the requested number of bytes exceeds that available in the raw data, `get_unsealed_range` will write fewer
/// than `num_bytes` bytes to `output_path`.
///
/// # Arguments
///
/// * `ss_ptr`       - pointer to a boxed SectorStore
/// * `sealed_path`  - path of sealed sector-file
/// * `output_path`  - path where sector file's unsealed bytes should be written
/// * `start_offset` - zero-based byte offset in original, unsealed sector-file
/// * `num_bytes`    - number of bytes to unseal and get (corresponds to contents of unsealed sector-file)
/// * `prover_id`    - uniquely identifies the prover
/// * `sector_id`    - uniquely identifies the sector
#[no_mangle]
pub unsafe extern "C" fn get_unsealed_range(
    ss_ptr: *mut Box<SectorStore>,
    sealed_path: SectorAccess,
    output_path: SectorAccess,
    start_offset: u64,
    num_bytes: u64,
    prover_id: &[u8; 31],
    sector_id: &[u8; 31],
) -> *mut responses::GetUnsealedRangeResponse {
    let mut response: responses::GetUnsealedRangeResponse = Default::default();

    let sealed_path_buf = c_str_to_pbuf(sealed_path);
    let output_path_buf = c_str_to_pbuf(output_path);

    match internal::get_unsealed_range(
        &**ss_ptr,
        &sealed_path_buf,
        &output_path_buf,
        *prover_id,
        *sector_id,
        start_offset,
        num_bytes,
    ) {
        Ok(num_bytes_unsealed) => {
            if num_bytes_unsealed == num_bytes {
                response.status_code = FCPResponseStatus::FCPNoError;
            } else {
                response.status_code = FCPResponseStatus::FCPReceiverError;

                let msg = CString::new(format!(
                    "expected to unseal {}-bytes, but unsealed {}-bytes",
                    num_bytes, num_bytes_unsealed
                ))
                .unwrap();
                response.error_msg = msg.as_ptr();
                mem::forget(msg);
            }
            response.num_bytes_written = num_bytes_unsealed;
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err.into());
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// Unseals an entire sealed sector and writes the resulting raw (unpreprocessed) sector to `output_path`.
/// Returns a status code indicating success or failure.
///
/// # Arguments
///
/// * `ss_ptr`      - pointer to a boxed SectorStore
/// * `sealed_path` - path of sealed sector-file
/// * `output_path` - path where sector file's unsealed bytes should be written
/// * `prover_id`   - uniquely identifies the prover
/// * `sector_id`   - uniquely identifies the sector
#[no_mangle]
pub unsafe extern "C" fn get_unsealed(
    ss_ptr: *mut Box<SectorStore>,
    sealed_path: SectorAccess,
    output_path: SectorAccess,
    prover_id: &[u8; 31],
    sector_id: &[u8; 31],
) -> *mut responses::GetUnsealedResponse {
    let mut response: responses::GetUnsealedResponse = Default::default();

    // How to read: &**ss_ptr throughout:
    // ss_ptr is a pointer to a Box
    // *ss_ptr is the Box.
    // **ss_ptr is the Box's content: a SectorStore.
    // &**ss_ptr is a reference to the SectorStore.
    let sector_store = &**ss_ptr;

    let sealed_path_buf = c_str_to_pbuf(sealed_path);
    let output_path_buf = c_str_to_pbuf(output_path);
    let sector_bytes = sector_store.config().max_unsealed_bytes_per_sector();

    match internal::get_unsealed_range(
        sector_store,
        &sealed_path_buf,
        &output_path_buf,
        *prover_id,
        *sector_id,
        0,
        sector_bytes,
    ) {
        Ok(num_bytes) => {
            if num_bytes == sector_bytes {
                response.status_code = FCPResponseStatus::FCPNoError;
            } else {
                response.status_code = FCPResponseStatus::FCPReceiverError;

                let msg = CString::new(format!(
                    "expected to unseal {}-bytes, but unsealed {}-bytes",
                    sector_bytes, num_bytes
                ))
                .unwrap();
                response.error_msg = msg.as_ptr();
                mem::forget(msg);
            }
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err.into());
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// Generates a proof-of-spacetime for the given replica commitments.
///
/// # Arguments
///
/// * `flattened_comm_rs_ptr` - pointer to the first cell in an array containing replica commitment
///                             bytes
/// * `flattened_comm_rs_len` - number of bytes in the flattened_comm_rs_ptr array (must be a
///                             multiple of 32)
/// * `_challenge_seed`       - currently unused
#[no_mangle]
pub unsafe extern "C" fn generate_post(
    flattened_comm_rs_ptr: *const u8,
    flattened_comm_rs_len: libc::size_t,
    _challenge_seed: &[u8; 32],
) -> *mut responses::GeneratePoSTResponse {
    let comm_rs = from_raw_parts(flattened_comm_rs_ptr, flattened_comm_rs_len)
        .iter()
        .step_by(32)
        .fold(Default::default(), |mut acc: Vec<[u8; 32]>, item| {
            let sliced = from_raw_parts(item, 32);
            let mut x: [u8; 32] = Default::default();
            x.copy_from_slice(&sliced[..32]);
            acc.push(x);
            acc
        });

    // if more than one comm_r was provided, pretend like the first was faulty
    let fault_idxs: Vec<u64> = vec![0]
        .into_iter()
        .take(if comm_rs.len() > 1 { 1 } else { 0 })
        .collect();

    let mut result: responses::GeneratePoSTResponse = Default::default();

    result.faults_len = fault_idxs.len();
    result.faults_ptr = fault_idxs.as_ptr();

    // tell Rust to forget about the Vec; we'll free it when we free the GeneratePoSTResult
    mem::forget(fault_idxs);

    // write some fake proof
    result.proof = [42; API_POST_PROOF_BYTES];

    Box::into_raw(Box::new(result))
}

/// Verifies that a proof-of-spacetime is valid.
///
/// # Arguments
///
/// * `_ss_ptr` - pointer to a boxed SectorStore
/// * `proof`   - a proof-of-spacetime
#[no_mangle]
pub extern "C" fn verify_post(
    proof: &[u8; API_POST_PROOF_BYTES],
) -> *mut responses::VerifyPoSTResponse {
    let mut res: responses::VerifyPoSTResponse = Default::default();

    if proof[0] == 42 {
        res.is_valid = true
    } else {
        res.is_valid = false
    };

    Box::into_raw(Box::new(res))
}

/// Initializes and returns a SectorBuilder.
///
#[no_mangle]
pub unsafe extern "C" fn init_sector_builder(
    sector_store_config_ptr: *const ConfiguredStore,
    last_used_sector_id: u64,
    metadata_dir: *const libc::c_char,
    prover_id: &[u8; 31],
    sealed_sector_dir: *const libc::c_char,
    staged_sector_dir: *const libc::c_char,
    max_num_staged_sectors: u8,
) -> *mut responses::InitSectorBuilderResponse {
    let mut response: responses::InitSectorBuilderResponse = Default::default();

    if let Some(cfg) = sector_store_config_ptr.as_ref() {
        match SectorBuilder::init_from_metadata(
            &cfg.into(),
            last_used_sector_id,
            c_str_to_rust_str(metadata_dir).to_string(),
            *prover_id,
            c_str_to_rust_str(sealed_sector_dir).to_string(),
            c_str_to_rust_str(staged_sector_dir).to_string(),
            max_num_staged_sectors,
        ) {
            Ok(sb) => {
                response.status_code = FCPResponseStatus::FCPNoError;
                response.sector_builder = raw_ptr(sb);
            }
            Err(err) => {
                let (code, ptr) = err_code_and_msg(&err);
                response.status_code = code;
                response.error_msg = ptr;
            }
        }
    } else {
        response.status_code = FCPResponseStatus::FCPCallerError;

        let msg = CString::new("caller did not provide ConfiguredStore").unwrap();
        response.error_msg = msg.as_ptr();
        mem::forget(msg);
    }

    raw_ptr(response)
}

/// Destroys a SectorBuilder.
///
#[no_mangle]
pub unsafe extern "C" fn destroy_sector_builder(ptr: *mut SectorBuilder) {
    let _ = Box::from_raw(ptr);
}

/// Writes user piece-bytes to a staged sector and returns the id of the sector
/// to which the bytes were written.
///
#[no_mangle]
pub unsafe extern "C" fn add_piece(
    ptr: *mut SectorBuilder,
    piece_key: *const libc::c_char,
    piece_ptr: *const u8,
    piece_len: libc::size_t,
) -> *mut responses::AddPieceResponse {
    let piece_key = c_str_to_rust_str(piece_key);
    let piece_bytes = from_raw_parts(piece_ptr, piece_len);

    let mut response: responses::AddPieceResponse = Default::default();

    match (*ptr).add_piece(String::from(piece_key), piece_bytes) {
        Ok(sector_id) => {
            response.status_code = FCPResponseStatus::FCPNoError;
            response.sector_id = sector_id;
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// Unseals and returns the bytes associated with the provided piece key.
///
#[no_mangle]
pub unsafe extern "C" fn read_piece_from_sealed_sector(
    ptr: *mut SectorBuilder,
    piece_key: *const libc::c_char,
) -> *mut responses::ReadPieceFromSealedSectorResponse {
    let mut response: responses::ReadPieceFromSealedSectorResponse = Default::default();

    let piece_key = c_str_to_rust_str(piece_key);

    match (*ptr).read_piece_from_sealed_sector(String::from(piece_key)) {
        Ok(piece_bytes) => {
            response.status_code = FCPResponseStatus::FCPNoError;
            response.data_ptr = piece_bytes.as_ptr();
            response.data_len = piece_bytes.len();
            mem::forget(piece_bytes);
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// For demo purposes. Seals all staged sectors.
///
#[no_mangle]
pub unsafe extern "C" fn seal_all_staged_sectors(
    ptr: *mut SectorBuilder,
) -> *mut responses::SealAllStagedSectorsResponse {
    let mut response: responses::SealAllStagedSectorsResponse = Default::default();

    match (*ptr).seal_all_staged_sectors() {
        Ok(_) => {
            response.status_code = FCPResponseStatus::FCPNoError;
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

/// Returns the number of user bytes that will fit into a staged sector.
///
#[no_mangle]
pub unsafe extern "C" fn get_max_user_bytes_per_staged_sector(
    ptr: *mut SectorBuilder,
) -> *mut responses::GetMaxStagedBytesPerSector {
    let mut response: responses::GetMaxStagedBytesPerSector = Default::default();

    response.status_code = FCPResponseStatus::FCPNoError;
    response.max_staged_bytes_per_sector = (*ptr).get_max_user_bytes_per_staged_sector();;

    raw_ptr(response)
}

/// Returns sector sealing status for the provided sector id if it exists. If
/// we don't know about the provided sector id, produce an error.
///
#[no_mangle]
pub unsafe extern "C" fn get_seal_status(
    ptr: *mut SectorBuilder,
    sector_id: u64,
) -> *mut responses::GetSealStatusResponse {
    let mut response: responses::GetSealStatusResponse = Default::default();

    match (*ptr).get_seal_status(sector_id) {
        Ok(seal_status) => {
            response.status_code = FCPResponseStatus::FCPNoError;

            match seal_status {
                SealStatus::Sealed(meta) => {
                    let meta = *meta;

                    response.seal_status_code = FFISealStatus::Sealed;
                    response.comm_d = meta.comm_d;
                    response.comm_r = meta.comm_r;
                    response.comm_r_star = meta.comm_r_star;
                    response.snark_proof = meta.snark_proof;
                    response.sector_id = meta.sector_id;
                    response.sector_access = rust_str_to_c_str(meta.sector_access);

                    let pieces = meta
                        .pieces
                        .iter()
                        .map(|p| FFIPieceMetadata {
                            piece_key: rust_str_to_c_str(p.piece_key.to_string()),
                            num_bytes: p.num_bytes,
                        })
                        .collect::<Vec<FFIPieceMetadata>>();

                    response.pieces_ptr = pieces.as_ptr();
                    response.pieces_len = pieces.len();

                    mem::forget(pieces);
                }
                SealStatus::Sealing => {
                    response.seal_status_code = FFISealStatus::Sealing;
                }
                SealStatus::Pending => {
                    response.seal_status_code = FFISealStatus::Pending;
                }
                SealStatus::Failed(err) => {
                    response.seal_status_code = FFISealStatus::Failed;
                    response.seal_error_msg = rust_str_to_c_str(err);
                }
            }
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

#[no_mangle]
pub unsafe extern "C" fn get_sealed_sectors(
    ptr: *mut SectorBuilder,
) -> *mut responses::GetSealedSectorsResponse {
    let mut response: responses::GetSealedSectorsResponse = Default::default();

    match (*ptr).get_sealed_sectors() {
        Ok(sealed_sectors) => {
            response.status_code = FCPResponseStatus::FCPNoError;

            let sectors = sealed_sectors
                .iter()
                .map(|meta| {
                    let pieces = meta
                        .pieces
                        .iter()
                        .map(|p| FFIPieceMetadata {
                            piece_key: rust_str_to_c_str(p.piece_key.to_string()),
                            num_bytes: p.num_bytes,
                        })
                        .collect::<Vec<FFIPieceMetadata>>();

                    let sector = responses::FFISealedSectorMetadata {
                        comm_d: meta.comm_d,
                        comm_r: meta.comm_r,
                        comm_r_star: meta.comm_r_star,
                        sector_access: rust_str_to_c_str(meta.sector_access.clone()),
                        sector_id: meta.sector_id,
                        snark_proof: meta.snark_proof,
                        pieces_len: pieces.len(),
                        pieces_ptr: pieces.as_ptr(),
                    };

                    mem::forget(pieces);

                    sector
                })
                .collect::<Vec<responses::FFISealedSectorMetadata>>();

            response.sectors_len = sectors.len();
            response.sectors_ptr = sectors.as_ptr();

            mem::forget(sectors);
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

#[no_mangle]
pub unsafe extern "C" fn get_staged_sectors(
    ptr: *mut SectorBuilder,
) -> *mut responses::GetStagedSectorsResponse {
    let mut response: responses::GetStagedSectorsResponse = Default::default();

    match (*ptr).get_staged_sectors() {
        Ok(staged_sectors) => {
            response.status_code = FCPResponseStatus::FCPNoError;

            let sectors = staged_sectors
                .iter()
                .map(|meta| {
                    let pieces = meta
                        .pieces
                        .iter()
                        .map(|p| FFIPieceMetadata {
                            piece_key: rust_str_to_c_str(p.piece_key.to_string()),
                            num_bytes: p.num_bytes,
                        })
                        .collect::<Vec<FFIPieceMetadata>>();

                    let mut sector = responses::FFIStagedSectorMetadata {
                        sector_access: rust_str_to_c_str(meta.sector_access.clone()),
                        sector_id: meta.sector_id,
                        pieces_len: pieces.len(),
                        pieces_ptr: pieces.as_ptr(),
                        seal_status_code: FFISealStatus::Pending,
                        seal_error_msg: ptr::null(),
                    };

                    match meta.seal_status {
                        SealStatus::Failed(ref s) => {
                            sector.seal_status_code = FFISealStatus::Failed;
                            sector.seal_error_msg = rust_str_to_c_str(s.clone());
                        }
                        SealStatus::Sealing => {
                            sector.seal_status_code = FFISealStatus::Sealing;
                        }
                        SealStatus::Pending => {
                            sector.seal_status_code = FFISealStatus::Pending;
                        }
                        SealStatus::Sealed(_) => {
                            sector.seal_status_code = FFISealStatus::Sealed;
                        }
                    };

                    mem::forget(pieces);

                    sector
                })
                .collect::<Vec<responses::FFIStagedSectorMetadata>>();

            response.sectors_len = sectors.len();
            response.sectors_ptr = sectors.as_ptr();

            mem::forget(sectors);
        }
        Err(err) => {
            let (code, ptr) = err_code_and_msg(&err);
            response.status_code = code;
            response.error_msg = ptr;
        }
    }

    raw_ptr(response)
}

impl<'a> Into<SBConfiguredStore> for &'a ConfiguredStore {
    fn into(self) -> SBConfiguredStore {
        match self {
            ConfiguredStore::Live => SBConfiguredStore::Live,
            ConfiguredStore::Test => SBConfiguredStore::Test,
            ConfiguredStore::ProofTest => SBConfiguredStore::ProofTest,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::{thread_rng, Rng};
    use sector_base::api::disk_backed_storage::{
        init_new_proof_test_sector_store, init_new_sector_store, init_new_test_sector_store,
        SBConfiguredStore,
    };
    use sector_base::api::responses::SBResponseStatus;
    use sector_base::api::responses::{
        destroy_new_sealed_sector_access_response, destroy_new_staging_sector_access_response,
        destroy_read_raw_response, destroy_write_and_preprocess_response,
    };
    use sector_base::api::{
        new_sealed_sector_access, new_staging_sector_access, read_raw, write_and_preprocess,
    };
    use std::ffi::CString;
    use std::fs::{create_dir_all, File};
    use std::io::Read;
    use std::thread;
    use tempfile;

    fn rust_str_to_c_str(s: &str) -> *const libc::c_char {
        CString::new(s).unwrap().into_raw()
    }

    fn create_storage(cs: &SBConfiguredStore) -> *mut Box<SectorStore> {
        let staging_path = tempfile::tempdir().unwrap().path().to_owned();
        let sealed_path = tempfile::tempdir().unwrap().path().to_owned();

        create_dir_all(&staging_path).expect("failed to create staging dir");
        create_dir_all(&sealed_path).expect("failed to create sealed dir");

        let s1 = rust_str_to_c_str(&staging_path.to_str().unwrap().to_owned());
        let s2 = rust_str_to_c_str(&sealed_path.to_str().unwrap().to_owned());

        match cs {
            SBConfiguredStore::Live => unsafe { init_new_sector_store(s1, s2) },
            SBConfiguredStore::Test => unsafe { init_new_test_sector_store(s1, s2) },
            SBConfiguredStore::ProofTest => unsafe { init_new_proof_test_sector_store(s1, s2) },
        }
    }

    // TODO: create a way to run these super-slow-by-design tests manually.
    //    fn seal_verify_live() {
    //        seal_verify_aux(ConfiguredStore::Live, 0);
    //        seal_verify_aux(ConfiguredStore::Live, 5);
    //    }
    //
    //    fn seal_unsealed_roundtrip_live() {
    //        seal_unsealed_roundtrip_aux(ConfiguredStore::Live, 0);
    //        seal_unsealed_roundtrip_aux(ConfiguredStore::Live, 5);
    //    }
    //
    //    fn seal_unsealed_range_roundtrip_live() {
    //        seal_unsealed_range_roundtrip_aux(ConfiguredStore::Live, 0);
    //        seal_unsealed_range_roundtrip_aux(ConfiguredStore::Live, 5);
    //    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_verify_test() {
        seal_verify_aux(SBConfiguredStore::Test, 0);
        seal_verify_aux(SBConfiguredStore::Test, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_verify_proof_test() {
        seal_verify_aux(SBConfiguredStore::ProofTest, 0);
        seal_verify_aux(SBConfiguredStore::ProofTest, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_unsealed_roundtrip_test() {
        seal_unsealed_roundtrip_aux(SBConfiguredStore::Test, 0);
        seal_unsealed_roundtrip_aux(SBConfiguredStore::Test, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_unsealed_roundtrip_proof_test() {
        seal_unsealed_roundtrip_aux(SBConfiguredStore::ProofTest, 0);
        seal_unsealed_roundtrip_aux(SBConfiguredStore::ProofTest, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_unsealed_range_roundtrip_test() {
        seal_unsealed_range_roundtrip_aux(SBConfiguredStore::Test, 0);
        seal_unsealed_range_roundtrip_aux(SBConfiguredStore::Test, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn seal_unsealed_range_roundtrip_proof_test() {
        seal_unsealed_range_roundtrip_aux(SBConfiguredStore::ProofTest, 0);
        seal_unsealed_range_roundtrip_aux(SBConfiguredStore::ProofTest, 5);
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn concurrent_seal_unsealed_range_roundtrip_proof_test() {
        let threads = 5;

        let spawned = (0..threads)
            .map(|_| {
                thread::spawn(|| seal_unsealed_range_roundtrip_aux(SBConfiguredStore::ProofTest, 0))
            })
            .collect::<Vec<_>>();

        for thread in spawned {
            thread.join().expect("test thread panicked");
        }
    }

    #[test]
    #[ignore] // Slow test – run only when compiled for release.
    fn write_and_preprocess_overwrites_unaligned_last_bytes() {
        write_and_preprocess_overwrites_unaligned_last_bytes_aux(SBConfiguredStore::ProofTest);
    }

    #[test]
    fn generate_verify_post_roundtrip_test() {
        generate_verify_post_roundtrip_aux();
    }

    #[test]
    fn max_unsealed_bytes_per_sector_checks() {
        assert_max_unsealed_bytes_per_sector(SBConfiguredStore::Live, 1065353216);
        assert_max_unsealed_bytes_per_sector(SBConfiguredStore::Test, 1016);
        assert_max_unsealed_bytes_per_sector(SBConfiguredStore::ProofTest, 127);
    }
    fn assert_max_unsealed_bytes_per_sector(cs: SBConfiguredStore, expected_bytes: u64) {
        let storage = create_storage(&cs);

        let bytes = unsafe {
            (&**storage as &SectorStore)
                .config()
                .max_unsealed_bytes_per_sector()
        };

        assert_eq!(
            bytes, expected_bytes,
            "wrong number of unsealed bytes for {:?}; got {}, expected {}",
            cs, bytes, expected_bytes
        );
    }

    fn generate_verify_post_roundtrip_aux() {
        unsafe {
            let comm_rs: [u8; 32] = thread_rng().gen();
            let challenge_seed: [u8; 32] = thread_rng().gen();
            let generate_post_res = generate_post(&comm_rs[0], 32, &challenge_seed);

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*generate_post_res).status_code,
                "generate_post failed"
            );

            let verify_post_res = verify_post(&(*generate_post_res).proof);

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*verify_post_res).status_code,
                "error verifying PoSt"
            );
            assert_eq!(true, (*verify_post_res).is_valid, "invalid PoSt");

            responses::destroy_generate_post_response(generate_post_res);
            responses::destroy_verify_post_response(verify_post_res);
        }
    }

    fn storage_bytes(sector_store: &'static SectorStore) -> usize {
        sector_store.config().max_unsealed_bytes_per_sector() as usize
    }

    fn make_data_for_storage(
        sector_store: &'static SectorStore,
        space_for_padding: usize,
    ) -> Vec<u8> {
        make_random_bytes(storage_bytes(sector_store) - space_for_padding)
    }

    fn make_random_bytes(num_bytes_to_make: usize) -> Vec<u8> {
        let mut rng = thread_rng();
        (0..num_bytes_to_make).map(|_| rng.gen()).collect()
    }

    fn seal_verify_aux(cs: SBConfiguredStore, byte_padding_amount: usize) {
        unsafe {
            let storage = create_storage(&cs);

            let cfg_ptr: *const ConfiguredStore = &match cs {
                SBConfiguredStore::Live => ConfiguredStore::Live,
                SBConfiguredStore::ProofTest => ConfiguredStore::ProofTest,
                SBConfiguredStore::Test => ConfiguredStore::Test,
            };

            let new_staging_sector_access_response = new_staging_sector_access(storage);
            let new_sealed_sector_access_response = new_sealed_sector_access(storage);

            let seal_input_path = (*new_staging_sector_access_response).sector_access;
            let seal_output_path = (*new_sealed_sector_access_response).sector_access;

            let prover_id = &[2; 31];
            let sector_id = &[0; 31];

            let contents = make_data_for_storage(&**storage, byte_padding_amount);

            let write_and_preprocess_response =
                write_and_preprocess(storage, seal_input_path, &contents[0], contents.len());

            assert_eq!(
                SBResponseStatus::SBNoError,
                (*write_and_preprocess_response).status_code,
                "write_and_preprocess failed for {:?}",
                cs
            );

            let seal_res = seal(
                storage,
                seal_input_path,
                seal_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*seal_res).status_code,
                "seal failed for {:?}",
                cs
            );

            let verify_seal_res = verify_seal(
                cfg_ptr,
                &(*seal_res).comm_r,
                &(*seal_res).comm_d,
                &(*seal_res).comm_r_star,
                prover_id,
                sector_id,
                &(*seal_res).proof,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*verify_seal_res).status_code,
                "verification failed with error for {:?}",
                cs
            );

            assert_eq!(
                true,
                (*verify_seal_res).is_valid,
                "verification of valid proof failed for {:?}",
                cs
            );

            // Make sure trying to verify a bad proof fails verification (returns false).
            {
                // This should always fail, because we've rotated the commitments in the call.
                let verify_seal_res = verify_seal(
                    cfg_ptr,
                    &(*seal_res).comm_d,
                    &(*seal_res).comm_r_star,
                    &(*seal_res).comm_r,
                    prover_id,
                    sector_id,
                    &(*seal_res).proof,
                );

                assert_eq!(
                    FCPResponseStatus::FCPNoError,
                    (*verify_seal_res).status_code,
                    "verification failed with error for {:?}",
                    cs
                );

                assert_eq!(
                    false,
                    (*verify_seal_res).is_valid,
                    "verification of invalid proof succeeded for {:?}",
                    cs
                );
            }
            responses::destroy_seal_response(seal_res);
            responses::destroy_verify_seal_response(verify_seal_res);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response);
            destroy_new_sealed_sector_access_response(new_sealed_sector_access_response);
            destroy_write_and_preprocess_response(write_and_preprocess_response);
        }
    }

    fn write_and_preprocess_overwrites_unaligned_last_bytes_aux(cs: SBConfiguredStore) {
        unsafe {
            let storage = create_storage(&cs);

            let new_staging_sector_access_response_a = new_staging_sector_access(storage);
            let new_staging_sector_access_response_b = new_staging_sector_access(storage);
            let new_sealed_sector_access_response = new_sealed_sector_access(storage);

            let seal_input_path = (*new_staging_sector_access_response_a).sector_access;
            let get_unsealed_range_output_path =
                (*new_staging_sector_access_response_b).sector_access;
            let seal_output_path = (*new_sealed_sector_access_response).sector_access;

            let prover_id = &[2; 31];
            let sector_id = &[0; 31];

            // The minimal reproduction for the bug this regression test checks is to write
            // 32 bytes, then 95 bytes.
            // The bytes must sum to 127, since that is the required unsealed sector size.
            // With suitable bytes (.e.g all 255),the bug always occurs when the first chunk is >= 32.
            // It never occurs when the first chunk is < 32.
            // The root problem was that write_and_preprocess was opening in append mode, so seeking backward
            // to overwrite the last, incomplete byte, was not happening.
            let contents_a = [255; 32];
            let contents_b = [255; 95];

            let write_and_preprocess_response_a =
                write_and_preprocess(storage, seal_input_path, &contents_a[0], contents_a.len());

            assert_eq!(
                SBResponseStatus::SBNoError,
                (*write_and_preprocess_response_a).status_code,
                "write_and_preprocess failed for {:?}",
                cs
            );

            assert_eq!(
                contents_a.len() as u64,
                (*write_and_preprocess_response_a).num_bytes_written,
                "unexpected number of bytes written {:?}",
                cs
            );

            let write_and_preprocess_response_b =
                write_and_preprocess(storage, seal_input_path, &contents_b[0], contents_b.len());

            assert_eq!(
                SBResponseStatus::SBNoError,
                (*write_and_preprocess_response_b).status_code,
                "write_and_preprocess failed for {:?}",
                cs
            );

            assert_eq!(
                contents_b.len() as u64,
                (*write_and_preprocess_response_b).num_bytes_written,
                "unexpected number of bytes written {:?}",
                cs
            );

            {
                let mut file = File::open(c_str_to_pbuf(seal_input_path)).unwrap();
                let mut buf = Vec::new();
                file.read_to_end(&mut buf).unwrap();
            }

            // TODO: We don't actually need to seal and unseal here.
            // We just need to unpreprocess.
            let seal_response = seal(
                storage,
                seal_input_path,
                seal_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*seal_response).status_code,
                "seal failed for {:?}",
                cs
            );

            let get_unsealed_response = get_unsealed(
                storage,
                seal_output_path,
                get_unsealed_range_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*get_unsealed_response).status_code,
                "get_unsealed failed for {:?}",
                cs
            );

            let mut file = File::open(c_str_to_pbuf(get_unsealed_range_output_path)).unwrap();
            let mut buf = Vec::new();
            file.read_to_end(&mut buf).unwrap();

            assert_eq!(
                contents_a.len() + contents_b.len(),
                buf.len(),
                "length of original and unsealed contents differed for {:?}",
                cs
            );

            assert_eq!(
                contents_a[..],
                buf[0..contents_a.len()],
                "original and unsealed contents differed for {:?}",
                cs
            );

            assert_eq!(
                contents_b[..],
                buf[contents_a.len()..contents_a.len() + contents_b.len()],
                "original and unsealed contents differed for {:?}",
                cs
            );

            // order doesn't matter here - just make sure we free so that tests don't leak
            responses::destroy_seal_response(seal_response);
            responses::destroy_get_unsealed_response(get_unsealed_response);
            destroy_new_sealed_sector_access_response(new_sealed_sector_access_response);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_a);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_b);
            destroy_write_and_preprocess_response(write_and_preprocess_response_a);
            destroy_write_and_preprocess_response(write_and_preprocess_response_b);
        }
    }

    fn seal_unsealed_roundtrip_aux(cs: SBConfiguredStore, byte_padding_amount: usize) {
        unsafe {
            let storage = create_storage(&cs);

            let new_staging_sector_access_response_a = new_staging_sector_access(storage);
            let new_staging_sector_access_response_b = new_staging_sector_access(storage);
            let new_sealed_sector_access_response = new_sealed_sector_access(storage);

            let seal_input_path = (*new_staging_sector_access_response_a).sector_access;
            let get_unsealed_output_path = (*new_staging_sector_access_response_b).sector_access;
            let seal_output_path = (*new_sealed_sector_access_response).sector_access;

            let prover_id = &[2; 31];
            let sector_id = &[0; 31];

            let contents = make_data_for_storage(&**storage, byte_padding_amount);

            let write_and_preprocess_response =
                write_and_preprocess(storage, seal_input_path, &contents[0], contents.len());

            assert_eq!(
                SBResponseStatus::SBNoError,
                (*write_and_preprocess_response).status_code,
                "write_and_preprocess failed for {:?}",
                cs
            );

            let seal_response = seal(
                storage,
                seal_input_path,
                seal_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*seal_response).status_code,
                "seal failed for {:?}",
                cs
            );

            let get_unsealed_response = get_unsealed(
                storage,
                seal_output_path,
                get_unsealed_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*get_unsealed_response).status_code,
                "get_unsealed failed for {:?}",
                cs
            );

            let mut file = File::open(c_str_to_pbuf(get_unsealed_output_path)).unwrap();
            let mut buf = Vec::new();
            file.read_to_end(&mut buf).unwrap();

            {
                let read_unsealed_response =
                    read_raw(storage, get_unsealed_output_path, 0, buf.len() as u64);

                assert_eq!(
                    (*read_unsealed_response).status_code,
                    SBResponseStatus::SBNoError
                );

                let read_unsealed_data = from_raw_parts(
                    (*read_unsealed_response).data_ptr,
                    (*read_unsealed_response).data_len,
                );
                assert_eq!(&buf, &read_unsealed_data);
                destroy_read_raw_response(read_unsealed_response);
            }

            {
                let read_unsealed_response =
                    read_raw(storage, get_unsealed_output_path, 1, buf.len() as u64 - 2);

                assert_eq!(
                    (*read_unsealed_response).status_code,
                    SBResponseStatus::SBNoError
                );

                let read_unsealed_data = from_raw_parts(
                    (*read_unsealed_response).data_ptr,
                    (*read_unsealed_response).data_len,
                );
                assert_eq!(&buf[1..buf.len() - 1], &read_unsealed_data[..]);
                destroy_read_raw_response(read_unsealed_response);
            }

            assert_eq!(
                contents.len(),
                buf.len() - byte_padding_amount,
                "length of original and unsealed contents differed for {:?}",
                cs
            );

            assert_eq!(
                contents[..],
                buf[0..contents.len()],
                "original and unsealed contents differed for {:?}",
                cs
            );

            // order doesn't matter here - just make sure we free so that tests don't leak
            responses::destroy_seal_response(seal_response);
            responses::destroy_get_unsealed_response(get_unsealed_response);
            destroy_new_sealed_sector_access_response(new_sealed_sector_access_response);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_a);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_b);
            destroy_write_and_preprocess_response(write_and_preprocess_response);
        }
    }

    fn seal_unsealed_range_roundtrip_aux(cs: SBConfiguredStore, byte_padding_amount: usize) {
        unsafe {
            let storage = create_storage(&cs);

            let new_staging_sector_access_response_a = new_staging_sector_access(storage);
            let new_staging_sector_access_response_b = new_staging_sector_access(storage);
            let new_sealed_sector_access_response = new_sealed_sector_access(storage);

            let seal_input_path = (*new_staging_sector_access_response_a).sector_access;
            let get_unsealed_range_output_path =
                (*new_staging_sector_access_response_b).sector_access;
            let seal_output_path = (*new_sealed_sector_access_response).sector_access;

            let prover_id = &[2; 31];
            let sector_id = &[0; 31];

            let contents = make_data_for_storage(&**storage, byte_padding_amount);

            let write_and_preprocess_response =
                write_and_preprocess(storage, seal_input_path, &contents[0], contents.len());

            assert_eq!(
                SBResponseStatus::SBNoError,
                (*write_and_preprocess_response).status_code,
                "write_and_preprocess failed for {:?}",
                cs
            );

            let seal_response = seal(
                storage,
                seal_input_path,
                seal_output_path,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*seal_response).status_code,
                "seal failed for {:?}",
                cs
            );

            let offset = 5;
            let range_length = contents.len() as u64 - offset;
            let get_unsealed_range_response = get_unsealed_range(
                storage,
                seal_output_path,
                get_unsealed_range_output_path,
                offset,
                range_length,
                prover_id,
                sector_id,
            );

            assert_eq!(
                FCPResponseStatus::FCPNoError,
                (*get_unsealed_range_response).status_code,
                "get_unsealed_range_response failed for {:?}",
                cs
            );
            assert_eq!(
                range_length,
                (*get_unsealed_range_response).num_bytes_written,
                "expected range length {}; got {} for {:?}",
                range_length,
                (*get_unsealed_range_response).num_bytes_written,
                cs
            );

            let mut file = File::open(c_str_to_pbuf(get_unsealed_range_output_path)).unwrap();
            let mut buf = Vec::new();
            file.read_to_end(&mut buf).unwrap();

            assert_eq!(
                contents[(offset as usize)..],
                buf[0..(range_length as usize)],
                "original and unsealed_range contents differed for {:?}",
                cs
            );

            responses::destroy_seal_response(seal_response);
            responses::destroy_get_unsealed_range_response(get_unsealed_range_response);
            destroy_new_sealed_sector_access_response(new_sealed_sector_access_response);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_a);
            destroy_new_staging_sector_access_response(new_staging_sector_access_response_b);
        }
    }
}
